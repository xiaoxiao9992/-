指令集架、指令与汇编语言

intel 64与IA32架构软件开发手册  https://software.intel.com/en-us/articles/intel-sdm
四卷合集
卷1: 描述了处理器的体系结构和编程环境支持ia-32和IntelA®64架构。
第二卷: 包括完整的指令集引用,a-z。 描述指令的格式和提供参考页说明。
第三卷: 包括完整的系统编程指南,1,2,3,4。 描述了操作系统的支持环境IntelA®64和ia-32的架构,包括:内存管理、保护、任务管理、
中断和异常处理,多处理器支持,热和电源管理功能,调试,性能监控,系统管理模式,虚拟机扩展(VMX)指令,IntelA®虚拟化技术(IntelA®VT),
和IntelA®软件保护扩展(IntelA®新交所)。
第四卷: 描述了模型相关的寄存器的处理器支持ia - 32和IntelA®64架构。

指令集架构简称指令集，ISA，CPU的执行单元和解码logic基本上由指令集决定。软件硬件之间的一个
接口，程序员根据CPU的指令集能编写各种各样的编译器，用高级语言编写程序。
指令集
	计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。
	指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。
	而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。
	每款CPU在设计时就规定了一系列与其硬件电路相配合的指令系统。指令的强弱也是CPU的重要指标，指令集是提高微处理器效率的最有效的工具之一。
	从现阶段的主流体系结构讲，指令集可分为复杂指令集和精简指令集两部分。

汇编语言属于指令集，指令集包括机器指令和汇编指令。一条机器指令对应一条汇编指令，
如mips中的000000机器码指令对应汇编指令的add假加法指令。汇编语言是便于人去理解的，
记着一条add指令总比000000容易吧。


指令的格式
一条指令一般包括两个部分：操作码和地址码。
a) 操作码其实就是指令序列号，用来告诉CPU需要执行的是那一条指令。
b) 地址码则复杂一些，主要包括源操作数地址、目的地址和下一条指令的地址。
在某些指令中，地址码可以部分或全部省略，比如一条空指令就只有操作码而没有地址码。


汇编语言......


编译型与解释型的区别
    编译型：运行前先由编译器将高级语言代码编译为对应机器的cpu汇编指令集，再由汇编器汇编为目标机器码，生成可执行文件，然最后运行生成的可执行文件。
	最典型的代表语言为C/C++，一般生成的可执行文件及.exe文件。

    解释型：在运行时由翻译器将高级语言代码翻译成易于执行的中间代码，并由解释器（例如浏览器、虚拟机）逐一将该中间代码
	解释成机器码并执行（可看做是将编译、运行合二为一了）。最典型的代表语言为JavaScript、Python、Ruby和Perl等

两种方式的异同之处：

(1) 转换为机器码的时机和运行效率
两种转换为机器码的方式，最大不同之处是处理转换为机器码的时机不同。
编译型是在运行前（且只编译一次），需要做转换工作，并生成一个可执行
的机器码文件，用户每次运行该可执行文件执行即可，效率、执行速度要比解释型的快。
因为解释型是在运行时做转换工作，并不生成可执行文件，所以每次运行都需要做一下
转换工作，然后再执行，效率自然就低了。

(2) 纠错排查
编译型语言，在编译阶段即可发现常见的语法或者链接等错误，此机制可在运行前帮助
程序员排查出可能潜在的语法、语义和类型转换错误，编译型语言一般都有明确的变量
类型检测，也被称作强类型语言，即编译型语言至少能确保所生成的可执行文件肯定是
可运行的，至于执行的逻辑不对则属于程序员业务逻辑错误范畴了。
而对于解释型语言，代码中的错误必须直到运行阶段方可发现，由此造成的困惑是：
往往一段程序看不出问题但却在运行阶段错误连连且需要一个个排查：变量拼写错误、
方法不存在等。但也正是基于解释是在运行期执行转化的特性，一般的解释型语言通常
都有自己的shell，可以在不确定某些执行结果是立即“动手执行”试一下，这就比每次都
需要编译后才能运行并看到结果省去不少时间，鱼和熊掌不可兼得的理念再一次被验证了。

(3) 可移植性
编译型在编译后生成的可执行文件，是相对与本机机器指令集的，所生成的可执行文件移
植到不同机器指令集的机器上，势必不一定能正常运行。而解释型的，尽管在不同配置的
机器上，也是最终会解释成基于当前机器指令集的机器码并执行，故解释型的可移植性相
对来说还是强于编译型的。

(4) 适用性
从第(1) 点我们知道编译型执行速度较解释型快，因为编译型会把大量时间花在编译上，
所以对机器和跨平台性的要求不高，开发操作系统、大型应用程序、数据库程序系统时一
般都采用编译型语言；而解释型由于每次运行都需要解释一遍，对机器有一定的配置要求
（在内存较小的机器上去一遍遍解释执行肯定是件很痛苦的事），适用的地方是一些例如
网页脚本、服务器脚本及辅助开发接口这类对机器配置要求不高、需要一定跨平台兼容性的程序。
鱼和熊掌可兼得吗？

综上所述，既然编译型与解释型各有优缺点又相互对立，所以一些语言都有把两者折衷起来的趋势：

Java为了实现跨平台的特性，专门在从高级语言代码转换至机器码过程的中间加入了一层中间层
JVM（java虚拟机），Java首先依赖编译器将代码（.java）编译成JVM能识别的字节码文件（.class）
，然后由JVM解释并执行改字节码，也可结合JIT（即时编译）技术，将解释生成的机器码转换为更
高效的本地机器码，且该机器码可被缓存，来提高重复执行的效率。这样的结合，令程序员在使用
Java时即可享受编译带来的强类型编译检查的好处，又能在执行时享受代码执行的高效性和跨平台
性，何乐而不为呢？

Python是解释型语言，但为了效率上的考虑，也提供了编译方式，编译后生成的也是字节码的文
件形式，并由Python的的VM（虚拟机）的去执行，这点可以说和Java的编译执行方式类似。不同点
在于，Python的编译并非强制执行的操作，确切来说Python的编译是自动的，通常发生在对某个模块
（module）的调用过程中，编译成字节码的可以节省加载模块的时间，以此达到提高效率的目的。可
见，某些先进的高级语言在对编译和解释方面的拿捏舍去，都采取了一种：两手抓，两手都要硬的态度哦:)


cpu
	地址总线
	控制总线
	数据总线
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	